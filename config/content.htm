<h1>About</h1>
<p>組長：41023119 呂承劼</p>
<p>組員：41023114 王樟皓、41023126 卓桓琮、41023138 林敬燐</p>
<p>倉儲 :<span> </span><a href="https://github.com/mdecd2023/2a2-pj2ag2">https://github.com/mdecd2023/2a2-pj1ag2</a></p>
<p>網站 : <a href="https://mdecd2023.github.io/2a2-pj2ag2/content/index.html">https://mdecd2023.github.io/2a2-pj2ag2/content/index.html</a></p>
<p><a href="https://mde.tw/pjcopsim">https://mde.tw/pjcopsim</a></p>
<h1>pj1</h1>
<p>w1-w9 pj1ag 各組製作之足球場景</p><h2>team10</h2>
<p>editor:<span>41023119 呂承劼 41023138 林敬燐</span></p>
<p>3/30 已完成場地及感測器</p>
<p><img alt="" height="405" src="/downloads/ag10/20230330.png" width="720"/></p>
<p>4/14 完成記分板程式</p>
<p><img alt="" height="405" src="/downloads/ag10/20230414.png" width="720"/></p>
<p>4/14 可進行計分</p>
<p>觸碰到感測器球及機器人會重置到原本的位置</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/QrEx-9oWQ-c" title="YouTube video player" width="560"></iframe></p>
<p>在錄影時記分板不會顯示出來-附上圖片</p>
<p><img alt="" height="405" src="/downloads/ag10/20230414-1.png" width="720"/></p>
<p>當分數為5分時，會暫停模擬</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/fWbkG7gVaFw" title="YouTube video player" width="560"></iframe></p>
<p>在製作感測器時求記得把 collidable、measurable、detectable 這三個選項打開</p>
<p><img alt="" height="405" src="/downloads/ag10/20230414-2.png" width="720"/></p>
<p>另外要注意的是感測器 z軸的部分不能為0，否則感測器會直接偵測到地板導致程式暫停模擬</p>
<p><span style="background-color: #00ffff;">記分板程式註解</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    score1 = 0 -- 初始化一個名為score1的變數，值為0
    
    sensor = sim.getObject('./sensor') -- 從模擬場景中獲取一個名為sensor的物體
    
    -- 創建一個UI，包括標題、計分標籤和當前分數值標籤，使用plastique風格
    xml = [[
        &lt;ui title="Scoreboard" closeable="false" resizable="false" style="plastique"&gt;
        &lt;label text="Score:" style="* {background-color: #808080; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px; }" id="10"/&gt;
        &lt;label text="0" style="* {background-color: #FFF; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;}" id="30"/&gt;
     
        &lt;/ui&gt;
    ]]
    ui = simUI.create(xml) -- 創建UI
    simUI.setPosition(ui, 0,0, true) -- 將UI定位在屏幕左上角
    bubbleRob = sim.getObject('/bubbleRob') -- 從模擬場景中獲取名為bubbleRob的物體句柄
    ball = sim.getObject('/ball') -- 從模擬場景中獲取名為ball的物體句柄
    bubbleRob2 = sim.getObject('/bubbleRob2') -- 從模擬場景中獲取名為bubbleRob2的物體句柄
    initialPosition = sim.getObjectPosition(bubbleRob, -1) -- 獲取bubbleRob物體的初始位置
    initialOrientation = sim.getObjectOrientation(bubbleRob, -1) -- 獲取bubbleRob物體的初始方向
    initialPosition2 = sim.getObjectPosition(bubbleRob2, -1) -- 獲取bubbleRob2物體的初始位置
    initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1) -- 獲取bubbleRob2物體的初始方向
    initialballPosition = sim.getObjectPosition(ball, -1) -- 獲取ball物體的初始位置
    initialballOrientation = sim.getObjectOrientation(ball, -1) -- 獲取ball物體的初始方向

end

function sysCall_actuation()
    --simUI.setLabelText(ui, 30, tostring(sim.getFloatSignal("myVariable")))

    -- 讀取接近傳感器的距離值，將其存儲在result變數中
    result=sim.readProximitySensor(sensor)

    -- 如果分數小於5，則執行以下操作
    if(score1&lt;5)then

        -- 如果檢測到接近物體，則執行以下操作
        if(result&gt;0)then
            -- 將score1變數增加1
            score2 = score1+1

            -- 在UI中更新分數值標籤的文本為score2
            simUI.setLabelText(ui, 30, tostring(score2))

            -- 重置bubbleRob、bubbleRob2和ball物體的位置和方向
            sim.setObjectPosition(bubbleRob, -1, initialPosition)
            sim.setObjectOrientation(bubbleRob, -1, initialOrientation)
            sim.setObjectPosition(bubbleRob2, -1, initialPosition2)
            sim.setObjectOrientation(bubbleRob2, -1, initialOrientation2)
            sim.setObjectPosition(ball, -1, initialballPosition)
            sim.setObjectOrientation(ball, -1, initialballOrientation)

            -- 將score1設置為score2
            score1=score2
        end
    else
        -- 如果分數達到5，則暫停模擬
        sim.pauseSimulation()
    end
end</pre>
<p><span style="background-color: #00ffff;">倒數計時器程式註解</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">-- 初始化函數，初始化得分(score1)為0和計時器(count)為3600
function sysCall_init()
    -- initialize the score to 0
    score1 = 0 -- 初始化得分
    count = 3600 -- 初始化計時器
    -- 獲取接近傳感器對象並創建UI界面
    sensor = sim.getObject('./sensor')
    xml = [[
            &lt;ui title="Scoreboard" closeable="false" resizable="false" style="plastique"&gt;
              &lt;label text="60:00.0" style="* {background-color: #F00; color: #FFF; font-size: 32px; font-weight: bold; padding: 4px; border-radius: 4px;}" id="10"/&gt;
              &lt;label text="Score:" style="* {background-color: #808080; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px; }" id="20"/&gt;
              &lt;label text="0" style="* {background-color: #FFF; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;}" id="30"/&gt;
            &lt;/ui&gt;
          ]]
    ui = simUI.create(xml)
    simUI.setPosition(ui, 0, 0, true)
    -- 獲取對象及其初始位置/方向
    bubbleRob = sim.getObject('/bubbleRob')
    ball = sim.getObject('/ball')
    initialPosition = sim.getObjectPosition(bubbleRob, -1)
    initialOrientation = sim.getObjectOrientation(bubbleRob, -1)
    initialballPosition = sim.getObjectPosition(ball, -1)
    initialballOrientation = sim.getObjectOrientation(ball, -1)
    
end

function sysCall_actuation() -- 讀取接近傳感器值
    result=sim.readProximitySensor(sensor)
    -- 檢查得分是否小於5
    if(score1&lt;5)then
        -- 檢查接近傳感器是否檢測到某物
        if(result&gt;0)then
            -- 增加得分並更新UI標籤
            score2 = score1+1
            simUI.setLabelText(ui, 30, tostring(score2))
            -- 重置對象的位置和方向
            sim.setObjectPosition(bubbleRob, -1, initialPosition)
            sim.setObjectOrientation(bubbleRob, -1, initialOrientation)
            sim.setObjectPosition(ball, -1, initialballPosition)
            sim.setObjectOrientation(ball, -1, initialballOrientation)
            -- 更新得分變量
            score1=score2
        end
    end
    if count &gt; 0 then -- 檢查計時器是否大於0
          count = count - 1 -- 減少倒數時間
          local minutes = math.floor(count / 60) -- 計算分鐘
          local seconds = count % 60 -- 計算秒數
          local timeStr = string.format("%d:%02d", minutes , seconds) -- 格式化時間字符串
          simUI.setLabelText(ui, 10, timeStr) -- 更新時間UI標籤
          simUI.setLabelText(ui, 30, tostring(score1)) -- 更新score的UI標籤
    else
        -- 如果時間到會暫停模擬
        sim.pauseSimulation()
    end
end</pre>
<p>可以將倒數計時器顯示出來，但計時器所減少的時間會比正常時間快好幾倍</p>
<p><img alt="" height="405" src="/downloads/ag10/20230414-3.png" width="720"/></p>
<p>bubbleRob_football 檔案 : <a href="/downloads/ag10/newbing_bubbleRob_football.ttt">bubbleRob_football_pj1ag10</a></p>
<p>加入連線對戰 bubbleRob_football 檔案 : <a href="/downloads/ag10/newbing_bubbleRob_football-2.ttt">bubbleRob_football-2_pj1ag10</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/N05LssWO1C8" title="YouTube video player" width="560"></iframe></p>
<p><span style="background-color: #00ffff;">連線remoteAPI程式註解</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false"># 引入必要的模块
from zmqRemoteApi import RemoteAPIClient
import keyboard
import sim
import time
import simConst

# 打印程式啟動的訊息
print('Program started')

# 關閉所有已開啟的連線
sim.simxFinish(-1)

# 連接到遠端 API 伺服器
clientID = sim.simxStart('192.168.56.1', 19998, True, True, 5000, 5)

# 啟動仿真
sim.simxStartSimulation(clientID, sim.simx_opmode_oneshot_wait)

# 判斷是否成功連線到伺服器
if clientID != -1:
    print('Connected to remote API server')
else:
    print('Failed connecting to remote API server')

# 打印仿真開始的訊息
print('Simulation started')

# 取得左右輪子的控制句柄
errorCode, leftMotor = sim.simxGetObjectHandle(clientID, 'leftMotor2', sim.simx_opmode_oneshot_wait)
errorCode, rightMotor = sim.simxGetObjectHandle(clientID, 'rightMotor2', sim.simx_opmode_oneshot_wait)

# 設定 BubbleRob 的速度
def setBubbleRobVelocity(leftWheelVelocity, rightWheelVelocity):
    # 取得左右輪子的控制句柄
    errorCode, leftMotor = sim.simxGetObjectHandle(clientID, '/leftMotor2', sim.simx_opmode_oneshot_wait)
    errorCode, rightMotor = sim.simxGetObjectHandle(clientID, '/rightMotor2',sim.simx_opmode_oneshot_wait)
    # 設定左右輪子的目標速度
    sim.simxSetJointTargetVelocity(clientID, leftMotor, leftWheelVelocity, simConst.simx_opmode_streaming)
    sim.simxSetJointTargetVelocity(clientID, rightMotor, rightWheelVelocity, simConst.simx_opmode_streaming)

# 循環檢測鍵盤事件
while True:
    if keyboard.is_pressed('up'):
        # 按下"上"鍵，前進
        setBubbleRobVelocity(2.0, 2.0)
    elif keyboard.is_pressed('down'):
        # 按下"下"鍵，後退
        setBubbleRobVelocity(-2.0, -2.0)
    elif keyboard.is_pressed('left'):
        # 按下"左"鍵，左轉
        setBubbleRobVelocity(-2.0, 2.0)
    elif keyboard.is_pressed('right'):
        # 按下"右"鍵，右轉
        setBubbleRobVelocity(2.0, -2.0)
    elif keyboard.is_pressed('q'):
        # 按下"q"鍵，停止仿真
        sim.stopSimulation()
    else:
        # 沒有按下任何鍵，停止移動
        setBubbleRobVelocity(0.0, 0.0)</pre>
<p>此程式必須放在圖片紅色框框檔案中</p>
<p><img alt="" height="405" src="/downloads/ag10/20230416.png" width="720"/></p>
<p><span style="background-color: #00ffff;">啟動遠端API程式註解</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">-- The main script is not supposed to be modified, except in special cases.
require('defaultMainScript')
function sysCall_init()
simRemoteApi.start(19998) -- 啟動遠程 API，監聽端口號為 19998
end</pre>
<p><span style="background-color: #00ffff;">連線 API sensor 程式註解</span><br/><br/></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">--在這個函數中初始化變數，設置UI元素，並獲取物體的初始位置和方向
function sysCall_init()
score1 = 0 --初始化分數變量
count = 24000 --初始化計時器變量，代表比賽時間，這裡設置為24000，即400秒
sensor = sim.getObject('./sensor') --獲取名為"sensor"的接近傳感器
--創建UI元素，顯示分數和計時器
xml2 = [[
&lt;ui title="計分板" closeable="false" resizable="false" style="plastique"&gt;
&lt;label text="分數：" style="* {background-color: #808080; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px; }" id="20"/&gt;
&lt;label text="0" style="* {background-color: #FFF; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;}" id="30"/&gt;
&lt;/ui&gt;
]]
ui = simUI.create(xml2) --創建計分板UI
simUI.setPosition(ui, 0,0, true) --設置UI位置
xml3 = [[
&lt;ui title="計時器" closeable="false" resizable="false" style="plastique"&gt;
&lt;label text="400:00.0" style="* {background-color: #F00; color: #FFF; font-size: 32px; font-weight: bold; padding: 4px; border-radius: 4px;}" id="10"/&gt;
&lt;/ui&gt;
]]
ui2 = simUI.create(xml3) --創建計時器UI
simUI.setPosition(ui2, 900,0, true) --設置UI位置
--獲取機器人和球的句柄，以及它們的初始位置和方向
bubbleRob = sim.getObject('/bubbleRob')
ball = sim.getObject('/ball')
bubbleRob2 = sim.getObject('/bubbleRob2')
initialPosition = sim.getObjectPosition(bubbleRob, -1)
initialOrientation = sim.getObjectOrientation(bubbleRob, -1)
initialPosition2 = sim.getObjectPosition(bubbleRob2, -1)
initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1)
initialballPosition = sim.getObjectPosition(ball, -1)
initialballOrientation = sim.getObjectOrientation(ball, -1)
end

--在這個函數中實現比賽計時和計分邏輯
function sysCall_actuation() -- 讀取接近傳感器值
    result=sim.readProximitySensor(sensor)
    -- 檢查得分是否小於5
    if(score1&lt;5)then
        -- 檢查接近傳感器是否檢測到某物
        if(result&gt;0)then
            -- 增加得分並更新UI標籤
            score2 = score1+1
            simUI.setLabelText(ui, 30, tostring(score2))
            -- 重置對象的位置和方向
            sim.setObjectPosition(bubbleRob, -1, initialPosition)
            sim.setObjectOrientation(bubbleRob, -1, initialOrientation)
            sim.setObjectPosition(bubbleRob2, -1, initialPosition2)
            sim.setObjectOrientation(bubbleRob2, -1, initialOrientation2)
            sim.setObjectPosition(ball, -1, initialballPosition)
            sim.setObjectOrientation(ball, -1, initialballOrientation)
            -- 更新得分變量
            score1=score2
        end
    end
    if count &gt; 0 then -- 檢查計時器是否大於0
          count = count - 1 -- 減少倒數時間
          local minutes = math.floor(count / 60) -- 計算分鐘
          local seconds = count % 60 -- 計算秒數
          local timeStr = string.format("%d:%02d", minutes , seconds) -- 格式化時間字符串
          simUI.setLabelText(ui, 10, timeStr) -- 更新時間UI標籤
          simUI.setLabelText(ui, 30, tostring(score1)) -- 更新score的UI標籤
    else
        -- 如果時間到會暫停模擬
        sim.pauseSimulation()
    end
end</pre>
<p><span style="background-color: #00ffff;">連線 API sensor2 程式註解</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
        score1 = 0 -- 初始分數為 0
        sensor = sim.getObject('./sensor2')  -- 取得感測器物件
        xml = [[
             &lt;ui title="Scoreboard" closeable="false" resizable="false" style="plastique"&gt;
             &lt;label text="Score:" style="* {background-color: #808080; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px; }" id="40"/&gt;
             &lt;label text="0" style="* {background-color: #FFF; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;}" id="50"/&gt;
              &lt;/ui&gt;
        ]]  -- 創建 UI 界面
        ui = simUI.create(xml)  -- 顯示 UI 界面
        simUI.setPosition(ui, 1770,0, true)  -- 設定 UI 界面的位置
        bubbleRob = sim.getObject('/bubbleRob')  -- 取得 BubbleRob 物件
        ball = sim.getObject('/ball')  -- 取得球物件
        bubbleRob2 = sim.getObject('/bubbleRob2')  -- 取得第二個 BubbleRob 物件
        initialPosition = sim.getObjectPosition(bubbleRob, -1)  -- 取得 BubbleRob 初始位置
        initialOrientation = sim.getObjectOrientation(bubbleRob, -1)  -- 取得 BubbleRob 初始方向
        initialPosition2 = sim.getObjectPosition(bubbleRob2, -1)  -- 取得第二個 BubbleRob 初始位置
        initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1)  -- 取得第二個 BubbleRob 初始方向
        initialballPosition = sim.getObjectPosition(ball, -1)  -- 取得球的初始位置
        initialballOrientation = sim.getObjectOrientation(ball, -1)  -- 取得球的初始方向
end

function sysCall_actuation()
     --simUI.setLabelText(ui, 30, tostring(sim.getFloatSignal("myVariable")))
     result=sim.readProximitySensor(sensor) -- 讀取感測器的值
     if(score1&lt;5)then -- 如果分數小於 5 分
       if(result&gt;0)then -- 如果感測器的值大於 0
        score2 = score1+1 -- 分數加 1
        simUI.setLabelText(ui, 50, tostring(score2)) -- 更新分數顯示
        sim.setObjectPosition(bubbleRob, -1, initialPosition)  -- 將 BubbleRob 重置到初始位置
        sim.setObjectOrientation(bubbleRob, -1, initialOrientation)  -- 將 BubbleRob 重置到初始方向
        sim.setObjectPosition(bubbleRob2, -1, initialPosition2)  -- 將第二個 BubbleRob 重置到初始位置
        sim.setObjectOrientation(bubbleRob2, -1, initialOrientation2)  -- 將第二個 BubbleRob 重置到初始方向
        sim.setObjectPosition(ball, -1, initialballPosition)  -- 將 Ball 重置到初始位置
        sim.setObjectOrientation(ball, -1, initialballOrientation)  -- 將 Ball 重置到初始方向
        -- 將score1設置為score2
        score1=score2
        end
    else
        -- 如果分數達到5，則暫停模擬
        sim.pauseSimulation()
    end
end</pre>
<p></p>
<p>所有檔案壓縮檔：<a href="/downloads/ag10/bubbleRob football 2a-pj1ag10.7z">bubbleRob football 2a-pj1ag10.7z</a></p><h2>team12</h2>
<p>editor:<span>41023114 王樟皓、41023126 卓桓琮</span></p>
<p><span><strong>Step1</strong>:建立足球場景，透過onshape繪出足球的場景，足球分成兩部分第一部分為足球的牆壁第二部分為球門。足球的牆壁:</span><a href="https://cad.onshape.com/documents/1ef9bb78edd5251adafdfbeb/w/0699139f42c9ebc4817c6156/e/20413e231639dd10dc11bb42?renderMode=0&amp;uiState=643a420fb4776c6d78624f23">wall</a><span> 球門:</span><a href="https://cad.onshape.com/documents/a377cc4e5b1ef7cab53572bc/w/239bf2d6c24d9f9c80b7a628/e/20ebee5effb2f8812f5d7e8a?renderMode=0&amp;uiState=643a427646ce454f67f78abb">door</a></p>
<p><span><strong>Step2</strong>:轉成STL檔匯入coppaliasim場景中，放入先前製作的bobbleRob robot，並複製兩個在場景中，加入球體 過程:<a href="https://youtu.be/Rc-BSnYI17w">https://youtu.be/Rc-BSnYI17w</a></span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Rc-BSnYI17w" width="560"></iframe></span></p>
<p><span><strong>Step3</strong>:設定coppliasim中的參數</span></p>
<p><span>1.在兩個球門上加入感應sensor，以感測是否進球，將兩個seonsor拉到球門底下</span></p>
<p><span><img alt="" height="313" src="/images/pj1-note1.png" width="556"/></span></p>
<p><span>2.設定ball的參數</span></p>
<p>
<script>
var winkVideoData_41023126 = {
  dataVersion: 1,
  frameRate: 10,
  buttonFrameLength: 5,
  buttonFrameOffset: 2,
  frameStops: {
  },
};
</script>
</p>
<!-- 接下來將 mp4 檔案從 downloads 目錄取出 -->
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/static" data-varname="winkVideoData_41023126" height="630" muted="true" width="1008">
<source src="./../downloads/ag12/pj1-ball.mp4" type="video/mp4"/></video></div>
<p><span></span>3.bubbleRob robot 參數設定:<a href="https://mdecd2023.github.io/2a-pj1ag12/content/%E8%A3%BD%E4%BD%9C%E9%81%8E%E7%A8%8B.html">bubbleRob</a></p>
<p><span><strong>Step4</strong>:加入sensor程式碼-利用chatgpt 寫出程式碼-計時器(記分板-參考至ag2)</span></p>
<p><span>文字檔:<a href="/downloads/ag12/sensor-program.txt">sensor-program</a></span></p>
<p><span><img alt="" height="393" src="/images/pj1-note4.png" width="469"/></span></p>
<p><span><img alt="" height="450" src="/images/pj1-note5.png" width="482"/></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    score1 = 0
    remaining_time = 60 -- 1 minute
    sensor = sim.getObject('./sensor')
    xml = [[        <ui closeable="false" resizable="false" title="Scoreboard">            <label id="10" style="* {background-color: #808080; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;" text="Score:"></label>            <label id="30" style="* {background-color: #1E90FF; color: #ffffff; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;" text="0"></label>            <label id="40" style="* {background-color: #808080; color: #000000; font-size: 20px; font-weight: bold; padding: 5px; border-radius: 5px;" text="Time left: 60s"></label>        </ui>    ]]
    ui = simUI.create(xml)
    simUI.setPosition(ui, 0,0, true)
    bubbleRob1 = sim.getObject('/bubbleRob1')
    ball = sim.getObject('/ball')
    bubbleRob2 = sim.getObject('/bubbleRob2')
    initialPosition = sim.getObjectPosition(bubbleRob1, -1)
    initialOrientation = sim.getObjectOrientation(bubbleRob1, -1)
    initialPosition2 = sim.getObjectPosition(bubbleRob2, -1)
    initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1)
    initialballPosition = sim.getObjectPosition(ball, -1)
    initialballOrientation = sim.getObjectOrientation(ball, -1)
end

function sysCall_actuation()
    -- read the proximity sensor value
    result=sim.readProximitySensor(sensor)
    -- check if the remaining time is greater than 0
    if(remaining_time &gt; 0) then
        -- check if the proximity sensor detects something
        if(result&gt;0) then
            -- increase the score and update the UI label
            score2 = score1+1
            simUI.setLabelText(ui, 30, tostring(score2))
            -- reset the objects' positions and orientations
            sim.setObjectPosition(bubbleRob1, -1, initialPosition)
            sim.setObjectOrientation(bubbleRob1, -1, initialOrientation)
            sim.setObjectPosition(bubbleRob2, -1, initialPosition2)
            sim.setObjectOrientation(bubbleRob2, -1, initialOrientation2)
            sim.setObjectPosition(ball, -1, initialballPosition)
            sim.setObjectOrientation(ball, -1, initialballOrientation)
            -- update the score variable
            score1=score2
        end
        -- update the remaining time and the UI label
        remaining_time = remaining_time - sim.getSimulationTimeStep()
        simUI.setLabelText(ui, 40, "Time left: "..math.floor(remaining_time).."s")
    else
        sim.stopSimulation()
    end
end</pre>
<p><span><strong>第二版 sersor 程式碼 </strong></span></p>
<p>文字檔:<a href="/downloads/ag12/sensor-program2.txt">sensor-program2</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    score1 = 0
    remaining_time = 1200 -- 20 minute
    sensor = sim.getObject('./sensor1')
    xml = [[        <ui closeable="false" resizable="false" title="Scoreboard">            <label id="10" style="* {background-color: #808080; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;" text="Score:"></label>            <label id="30" style="* {background-color: #1E90FF; color: #ffffff; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;" text="0"></label>            <label id="40" style="* {background-color: #d91111; color: #000000; font-size: 20px; font-weight: bold; padding: 5px; border-radius: 5px;" text="Time left: 60s"></label>        </ui>    ]]
    ui = simUI.create(xml)
    simUI.setPosition(ui, 0,0, true)
    bubbleRob1 = sim.getObject('/bubbleRob1')
    ball = sim.getObject('/ball')
    bubbleRob2 = sim.getObject('/bubbleRob2')
    initialPosition = sim.getObjectPosition(bubbleRob1, -1)
    initialOrientation = sim.getObjectOrientation(bubbleRob1, -1)
    initialPosition2 = sim.getObjectPosition(bubbleRob2, -1)
    initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1)
    initialballPosition = sim.getObjectPosition(ball, -1)
    initialballOrientation = sim.getObjectOrientation(ball, -1)
end

function sysCall_actuation()
    -- read the proximity sensor value
    result=sim.readProximitySensor(sensor)
    -- check if the remaining time is greater than 0
    if(remaining_time &gt; 0) then
        -- check if the proximity sensor detects something
        if(result&gt;0) then
            -- increase the score and update the UI label
            score2 = score1+1
            simUI.setLabelText(ui, 30, tostring(score2))
            -- reset the objects' positions and orientations
            sim.setObjectPosition(bubbleRob1, -1, initialPosition)
            sim.setObjectOrientation(bubbleRob1, -1, initialOrientation)
            sim.setObjectPosition(bubbleRob2, -1, initialPosition2)
            sim.setObjectOrientation(bubbleRob2, -1, initialOrientation2)
            sim.setObjectPosition(ball, -1, initialballPosition)
            sim.setObjectOrientation(ball, -1, initialballOrientation)
            -- update the score variable
            score1=score2
        end
        -- update the remaining time and the UI label
        remaining_time = remaining_time - sim.getSimulationTimeStep()
        simUI.setLabelText(ui, 40, "Time left: "..math.floor(remaining_time).."s")
    else
        sim.stopSimulation()
    end
end</pre>
<p><span><strong></strong></span></p>
<p><span><strong>Step5</strong>:打開小白窗 加入程式碼 按go</span></p>
<p><span>文字檔:<a href="/downloads/ag12/senser1-whiteboard-program.txt">whitewindow</a></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># pip install pyzmq cbor
from zmqRemoteApi import RemoteAPIClient
import keyboard

client = RemoteAPIClient('localhost', 23000)

print('Program started')
sim = client.getObject('sim')
sim.startSimulation()
print('Simulation started')

def setBubbleRobVelocity(leftWheelVelocity, rightWheelVelocity):
    leftMotor = sim.getObject('/leftMotor')
    rightMotor = sim.getObject('/rightMotor')
    sim.setJointTargetVelocity(leftMotor, leftWheelVelocity)
    sim.setJointTargetVelocity(rightMotor, rightWheelVelocity)

'''
# Example usage 1:
setBubbleRobVelocity(1.0, 1.0)
time.sleep(2)
setBubbleRobVelocity(0.0, 0.0)
'''
# use keyborad to move BubbleRob

while True:
    if keyboard.is_pressed('up'):
        setBubbleRobVelocity(1.0, 1.0)
    elif keyboard.is_pressed('down'):
        setBubbleRobVelocity(-1.0, -1.0)
    elif keyboard.is_pressed('left'):
        setBubbleRobVelocity(-1.0, 1.0)
    elif keyboard.is_pressed('right'):
        setBubbleRobVelocity(1.0, -1.0)
    elif keyboard.is_pressed('q'):
        # stop simulation
        sim.stopSimulation()
    else:
        setBubbleRobVelocity(0.0, 0.0)</pre>
<p><strong>在football的場景加入計時器和記分板 過程:<a href="https://youtu.be/EZ_mE9P4j-s">https://youtu.be/EZ_mE9P4j-s</a></strong></p>
<p><strong>第一版</strong></p>
<p><strong></strong></p>
<p><img alt="" height="283" src="/images/pj1-note3.png" width="505"/></p>
<p></p>
<p><img alt="" height="267" src="/images/pj1-note2.png" width="508"/></p>
<p></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Dnn487BBg2E" width="560"></iframe></p>
<p><strong></strong></p>
<p><strong>第二版</strong></p>
<p><strong></strong></p>
<p><strong><img alt="" height="444" src="/images/pj1-note11.png" width="790"/></strong></p>
<p></p>
<p><img alt="" height="426" src="/images/pj1-note10.png" width="757"/></p>
<p></p>
<p><strong></strong></p>
<p><strong><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Js30bBYL3Wk" width="560"></iframe><br/></strong></p>
<p><strong></strong></p>
<p><strong>Step6</strong>:連線對戰</p>
<p>1.查詢ipconfig 找到ipv4埠號 </p>
<p><img alt="" height="343" src="/images/pj1-note6.png" width="544"/></p>
<p>2.將自己ipv4埠號複製到小白窗的程式中</p>
<p><img alt="" height="404" src="/images/pj1-note7.png" width="338"/></p>
<p><img alt="" height="344" src="/images/pj1-note8.png" width="272"/></p>
<p>3.開始兩人對戰</p>
<p><img alt="" height="252" src="/images/pj1-note9.png" width="448"/></p>
<p></p>
<p>Final:連線對打未完成 都有設定 防火牆也有關 但是對方就連不到</p>
<p>連線失敗過程:</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/hoakN4USk7A" width="560"></iframe></p>
<p></p>
<p>football.ttt檔:<a href="/downloads/ag12/pj1-football.ttt">pj1-football</a></p>
<p></p>
<h1>pj2</h1>
<p>4/17  4人操控 bubbleRob 利用 remote API server 錄製的影片</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/8Nqbb7NHTvE" title="YouTube video player" width="560"></iframe></p>
<p><span style="background-color: #00ffff;">remote API 程式</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># pip install pyzmq cbor
from zmqRemoteApi import RemoteAPIClient
import keyboard
import sim
import time
import simConst

print('Program started')
sim.simxFinish(-1) # just in case, close all openㄋed connections
clientID=sim.simxStart('192.168.1.35',19997,True,True,5000,5)
sim.simxStartSimulation(clientID, sim.simx_opmode_oneshot_wait)

if clientID!=-1:
    print('Connected to remote API server')
else:
    print('Failed connecting to remote API server')

print('Simulation started')

errorCode, leftMotor = sim.simxGetObjectHandle(clientID, 'leftMotor', sim.simx_opmode_oneshot_wait)
errorCode, rightMotor = sim.simxGetObjectHandle(clientID, 'rightMotor', sim.simx_opmode_oneshot_wait)

def setBubbleRobVelocity(leftWheelVelocity, rightWheelVelocity):
    errorCode, leftMotor = sim.simxGetObjectHandle(clientID, '/leftMotor', sim.simx_opmode_oneshot_wait)
    errorCode, rightMotor = sim.simxGetObjectHandle(clientID, '/rightMotor',sim.simx_opmode_oneshot_wait)
    sim.simxSetJointTargetVelocity(clientID, leftMotor, leftWheelVelocity, simConst.simx_opmode_streaming)
    sim.simxSetJointTargetVelocity(clientID, rightMotor, rightWheelVelocity, simConst.simx_opmode_streaming)

'''
# Example usage 1:
setBubbleRobVelocity(1.0, 1.0)
time.sleep(2)
setBubbleRobVelocity(0.0, 0.0)
'''
# use keyborad to move BubbleRob

while True:
    if keyboard.is_pressed('w'):
        setBubbleRobVelocity(2.0, 2.0)
    elif keyboard.is_pressed('s'):
        setBubbleRobVelocity(-2.0, -2.0)
    elif keyboard.is_pressed('a'):
        setBubbleRobVelocity(-2.0, 2.0)
    elif keyboard.is_pressed('d'):
        setBubbleRobVelocity(2.0, -2.0)
    elif keyboard.is_pressed('q'):
        # stop simulation
        sim.stopSimulation()
    else:
        setBubbleRobVelocity(0.0, 0.0)</pre>
<p><span style="background-color: #00ffff;"><span style="background-color: #ffffff;"></span></span></p>
<p><span style="background-color: #00ffff;"><span style="background-color: #ffffff;">控制 remote API 檔案：<a href="/downloads/bubbleRob_zmq_green_red_example.7z">bubbleRob_zmq_green_red_example.7z</a></span></span></p>
<p><span style="background-color: #00ffff;"><span style="background-color: #ffffff;"><span>遇到問題：一開始本組是利用三台教室電腦及一台筆電，開始模擬時唯獨筆電無法操控 bubbleRob，後來發現網路必需都要連至同一個 Wi-Fi 才能 zmqRemoteAPI 的操控。</span></span></span></p>
<p><span style="background-color: #00ffff;"><span style="background-color: #ffffff;"><span>5/1 </span></span></span>加入足球場景的記分板</p>
<div>因為在連線中，軟件中的計分板，分數無法顯示在連線的雙方的螢幕上，因此要加入的記分板，以顯示在雙方的得分數在連線的螢幕上。</div>
<div></div>
<div>經過討論本組所可執行的方案有兩種</div>
<div>1.利用機械式使用馬達直接傳動</div>
<div>2.利用程式控制顏色改變計分板分數</div>
<div></div>
<div>以下是利用機械式紀分板</div>
<div></div>
<div><span>機械式計分器 計分器變換方式使用<strong>馬達直接傳動</strong></span></div>
<div><span><strong></strong></span></div>
<div><span><strong><img alt="" height="331" src="/images/螢幕擷取畫面 2023-05-01 205446.png" width="285"/></strong></span></div>
<p>5/6 完成機械式記分板機構模型</p>
<p>第一版</p>
<p><img alt="" height="331" src="/images/記分板第一版-1.png" width="355"/></p>
<p><img alt="" height="269" src="/images/記分板第一版-2.png" width="390"/></p>
<p>在coppliasim中模擬放置</p>
<p><img alt="" height="302" src="/images/記分板第一版-3.png" width="402"/></p>
<p>程式部分正在研究及討論</p>
<p>5/8 經過討論後機械式計分板所需程式太過繁瑣，所以參考七段顯示器的概念修改計時器為顏色控制</p>
<p>記分板 prt 檔及 stl 檔：<a href="/downloads/score1.prt">score1.prt</a>、<a href="/downloads/score1_1.stl">score1_1.stl</a></p>
<p>以下是圖片效果展示</p>
<p><img alt="" height="405" src="/images/football/picture1.png" width="720"/></p>
<p>5/10 進球後可以控制個位數記分板更改分數</p>
<p>以下是程式註解及影片</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    scorewallb = 0  -- 累計分數 b
    scorewalla = 0  -- 累計分數 a
    sensor = sim.getObject('./sensor')  -- 感測器物件
    bubbleRob = sim.getObject('/bubbleRob')  -- 機器人物件
    ball = sim.getObject('/ball')  -- 球物件
    bubbleRob2 = sim.getObject('/bubbleRob2')  -- 第二個機器人物件
    initialPosition = sim.getObjectPosition(bubbleRob, -1)  -- 機器人的初始位置
    initialOrientation = sim.getObjectOrientation(bubbleRob, -1)  -- 機器人的初始姿態
    initialPosition2 = sim.getObjectPosition(bubbleRob2, -1)  -- 第二個機器人的初始位置
    initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1)  -- 第二個機器人的初始姿態
    initialballPosition = sim.getObjectPosition(ball, -1)  -- 球的初始位置
    initialballOrientation = sim.getObjectOrientation(ball, -1)  -- 球的初始姿態
    
    -- 分數的設定
    score0={1,1,1,0,1,1,1}
    score1={0,0,1,0,0,1,0}
    score2={1,0,1,1,1,0,1}
    score3={1,0,1,1,0,1,1}
    score4={0,1,1,1,0,1,0}
    score5={1,1,0,1,0,1,1}
    score6={1,1,0,1,1,1,1}
    score7={1,0,1,0,0,1,0}
    score8={1,1,1,1,1,1,1}
    score9={1,1,1,1,0,1,1}
    score={score0,score1,score2,score3,score4,score5,score6,score7,score8,score9}
    
    -- 設定每個計分牆的顏色
    for j = 0,6,1 do
        local scoreb = sim.getObject('./scoreb['..j..']')
        -- 如果 score[1][j+1] 等於 1，將計分牆設定為紅色；否則設定為白色
        if (score[1][j+1]==1) then
            sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0})
        else
            sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 1, 1})
        end
    end
end

function sysCall_actuation()
    result=sim.readProximitySensor(sensor)  -- 讀取感測器的結果
    if(scorewallb&lt;9)then
        if(result&gt;0)then
            score2 = scorewallb+1  -- 更新分數
            -- 判斷分數並更新計分牆的顏色
            for i= 0,9,1 do
                if (score2 == i)then
                    for j = 0,6,1 do
                        local scoreb = sim.getObject('./scoreb['..j..']')
                        -- 如果 score[i+1][j+1] 等於 1，將計分牆設定為紅色；否則設定為白色
                        if (score[i+1][j+1]==1) then
                            sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0})
                        else
                            sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 1, 1})
                        end
                    end
                end
            end
            --sim.pauseSimulation()
            scorewallb=score2  -- 更新累計分數
            sim.setObjectPosition(ball, -1, initialballPosition)  -- 重置球的位置
            sim.setObjectOrientation(ball, -1, initialballOrientation)  -- 重置球的姿態
        end
    else
        sim.pauseSimulation()  -- 暫停模擬
    end
end</pre>
<p></p>
<p></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/S5cWPZzXmrs" title="YouTube video player" width="560"></iframe></p>
<p>經過程式編譯可以更新十位數及個位數記分板分數，而以下是程式註解及影片</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    scorewallb = 0  -- 分數牆B的初始分數為0
    scorewalla = 0  -- 分數牆A的初始分數為0
    sensor = sim.getObject('./sensor')  -- 取得感應器的句柄
    bubbleRob = sim.getObject('/bubbleRob')  -- 取得機器人1的句柄
    ball = sim.getObject('/ball')  -- 取得球的句柄
    bubbleRob2 = sim.getObject('/bubbleRob2')  -- 取得機器人2的句柄
    initialPosition = sim.getObjectPosition(bubbleRob, -1)  -- 取得機器人1的初始位置
    initialOrientation = sim.getObjectOrientation(bubbleRob, -1)  -- 取得機器人1的初始姿態
    initialPosition2 = sim.getObjectPosition(bubbleRob2, -1)  -- 取得機器人2的初始位置
    initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1)  -- 取得機器人2的初始姿態
    initialballPosition = sim.getObjectPosition(ball, -1)  -- 取得球的初始位置
    initialballOrientation = sim.getObjectOrientation(ball, -1)  -- 取得球的初始姿態
    
    -- 分數牆顯示的數字0~9的顏色設定
    score0 = {1, 1, 1, 0, 1, 1, 1}
    score1 = {0, 0, 1, 0, 0, 1, 0}
    score2 = {1, 0, 1, 1, 1, 0, 1}
    score3 = {1, 0, 1, 1, 0, 1, 1}
    score4 = {0, 1, 1, 1, 0, 1, 0}
    score5 = {1, 1, 0, 1, 0, 1, 1}
    score6 = {1, 1, 0, 1, 1, 1, 1}
    score7 = {1, 0, 1, 0, 0, 1, 0}
    score8 = {1, 1, 1, 1, 1, 1, 1}
    score9 = {1, 1, 1, 1, 0, 1, 1}
    score = {score0, score1, score2, score3, score4, score5, score6, score7, score8, score9}

    -- 初始化分數牆A的顯示顏色
for j = 0, 6, 1 do
    local scorea = sim.getObject('./scorea[' .. j .. ']')
    
    -- 檢查分數牆A對應的分數是否為1
    if (score[1][j+1]==1) then
        sim.setShapeColor(scorea, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0}) -- 將形狀的顏色設定為紅色
    else
        sim.setShapeColor(scorea, nil, sim.colorcomponent_ambient_diffuse, {1, 1, 1}) -- 將形狀的顏色設定為白色
    end
end
    -- 初始化分數牆B的顯示顏色
for j = 0, 6, 1 do
    local scoreb = sim.getObject('./scoreb[' .. j .. ']')
    
    -- 檢查分數牆B對應的分數是否為1
    if (score[1][j+1]==1) then
        sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0}) -- 將形狀的顏色設定為紅色
    else
        sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 1, 1}) -- 將形狀的顏色設定為白色
    end
end

function sysCall_actuation()
    result = sim.readProximitySensor(sensor)  -- 讀取接近傳感器的值
    
    -- 檢查分數牆B的分數是否小於10
    if scorewallb &lt; 10 then
        -- 如果接近傳感器的值大於0，就執行以下程式
        if result &gt; 0 then
            score2 = scorewallb + 1  -- 更新分數牆B的分數
            
            -- 檢查新的分數對應的形狀顏色
            for i = 0, 9, 1 do
                if score2 == i then
                    -- 更新分數牆B的形狀顏色
                    for j = 0, 6, 1 do
                        local scoreb = sim.getObject('./scoreb[' .. j .. ']')
                        if score[i + 1][j + 1] == 1 then
                            sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0}) -- 將形狀的顏色設定為紅色
                        else
                            sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 1, 1}) -- 將形狀的顏色設定為白色
                        end
                    end
                end
            end
            
            scorewallb = score2  -- 更新分數牆B的分數
            sim.setObjectPosition(ball, -1, initialballPosition) -- 將球的位置重設為初始位置
            sim.setObjectOrientation(ball, -1, initialballOrientation) -- 將球的方向重設為初始方向
        end
    else
        scorewallb = 0  -- 如果分數牆B的分數達到9，則將分數牆B的分數重設為0
        
        -- 更新分數牆B的形狀顏色
        for j = 0, 6, 1 do
            local scoreb = sim.getObject('./scoreb[' .. j .. ']')
            if score0[j + 1] == 1 then
                sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0}) -- 將形狀的顏色設定為紅色
            else
                sim.setShapeColor(scoreb, nil, sim.colorcomponent_ambient_diffuse, {1, 1, 1}) -- 將形狀的顏色設定為白色
            end
        end
        
        score3 = scorewalla + 1  -- 更新分數牆A的分數

    -- 更新分數牆A的形狀顏色
        for i = 0, 9, 1 do
          if score3 == i then
            for j = 0, 6, 1 do
                local scorea = sim.getObject('./scorea[' .. j .. ']')
                if score[i + 1][j + 1] == 1 then
                    sim.setShapeColor(scorea, nil, sim.colorcomponent_ambient_diffuse, {1, 0, 0}) -- 將 scorea 物體的顏色設置為紅色
                else
                    sim.setShapeColor(scorea, nil, sim.colorcomponent_ambient_diffuse, {1, 1, 1}) -- 將 scorea 物體的顏色設置為白色
                end
            end
          end
        end
        scorewalla = score3 -- 將 scorewalla 變數的值設置為 score3 的值
        sim.setObjectPosition(ball, -1, initialballPosition) -- 將 ball 物體的位置設置為初始位置
        sim.setObjectOrientation(ball, -1, initialballOrientation) -- 將 ball 物體的方向設置為初始方向
    
    -- 如果 scorewallb 和 scorewalla 都等於 9，則暫停仿真
    if scorewallb == 9 and scorewalla == 9 then
        sim.pauseSimulation()
    end
end</pre>
<p></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/PTypbITJJG4" title="YouTube video player" width="560"></iframe></p>
<p></p><h2>41023114</h2>
<p>w10</p>
<p>1.What is zmqRemoteAPI, and how does it relate to CoppeliaSim?</p>
<p>   zmqRemoteAPI是什麼，它如何與CoppeliaSim相關聯？</p>
<p>answer:</p>
<p>zmqRemoteAPI 是 CoppeliaSim 提供的一個用於遠端控制仿真場景的工具。它基於 ZeroMQ 庫實現，可以在 Python、MATLAB、C++、Java、Octave 等多種編程語言中使用。使用 zmqRemoteAPI，可以通過編程控制 CoppeliaSim 中的機器人、傳感器、物體等各種元件，實現自動化控制、遠端操作、仿真驗證等功能。 因此，zmqRemoteAPI 是 CoppeliaSim 中的一個重要功能，使得使用者可以通過編程方式控制和操作仿真場景中的各種元件，進而實現更加靈活和高效的仿真操作。</p>
<p>5.Can you give an example of a project or task that you could complete using zmqRemoteAPI in CoppeliaSim?</p>
<p>   能否舉一個使用zmqRemoteAPI在CoppeliaSim中完成的項目或任務的例子？ </p>
<div><span>answer:以下是一個使用</span><span> </span><span>CoppeliaSim</span><span> </span><span>的</span><span> </span><span>zmqRemoteAPI</span><span> </span><span>控制機械臂自動抓取物體的</span><span> </span><span>Python</span><span> </span><span>程序</span></div>
<div></div>
<div>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sim import time # 定義物體的名稱和位置
object_name = 'Cuboid' object_position = [-0.2, 0.5, 0.1] # 連接 CoppeliaSim sim.simxFinish(-1) clientID = sim.simxStart('127.0.0.1', 19999, True, True, 5000, 5) 
if clientID != -1: print('Connected to remote API server') # 取得機械臂控制句柄
errorCode, robot_handle = sim.simxGetObjectHandle(clientID, 'UR3', sim.simx_opmode_blocking) # 取得物體控制句柄
errorCode, object_handle = sim.simxGetObjectHandle(clientID, object_name, sim.simx_opmode_blocking) # 移動機械臂到指定位置
target_position = [-0.2, 0.5, 0.2] sim.simxSetObjectPosition(clientID, robot_handle, -1, target_position, sim.simx_opmode_blocking) # 機械臂夾取物體 sim.simxSetObjectParent(clientID, object_handle, robot_handle, True, sim.simx_opmode_blocking) # 移動機械臂到指定位置
sim.simxSetObjectPosition(clientID, robot_handle, -1, object_position, sim.simx_opmode_blocking) # 釋放夾爪
sim.simxSetObjectParent(clientID, object_handle, -1, True, sim.simx_opmode_blocking) # 移動機械臂到指定位置
sim.simxSetObjectPosition(clientID, robot_handle, -1, target_position, sim.simx_opmode_blocking) # 斷開與 CoppeliaSim 的連接
sim.simxFinish(clientID) else: print('Failed connecting to remote API server') time.sleep(1)</pre>
<p><span>這個</span><span><span> </span></span><span>Python</span><span><span> </span></span><span>程序通過</span><span><span> </span></span><span>CoppeliaSim</span><span><span> </span></span><span>的</span><span><span> </span></span><span>zmqRemoteAPI</span><span><span> </span></span><span>連接到</span><span><span> </span></span><span>CoppeliaSim</span><span><span> </span></span><span>仿真環境，控制機械臂移動到指定位置，夾取物體並將其移動到另一個位置，最後釋放夾爪。這個程序可以應用於機械臂自動化抓取和放置物體的項目或任務。</span></p>
</div>
<p><span style="background-color: #00ffff;"><span style="background-color: #ffffff;"><span>遇到問題：一開始本組是利用三台教室電腦及一台筆電，開始模擬時唯獨筆電無法操控 bubbleRob，後來發現網路必需都要連至同一個 Wi-Fi 才能 zmqRemoteAPI 的操控。</span></span></span></p>
<h2>41023119</h2>
<p>pj2 製作內容</p>
<p>4人操控 bubbleRob 利用 remote API server 錄製的影片</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/8Nqbb7NHTvE" title="YouTube video player" width="560"></iframe></p>
<p><span style="background-color: #00ffff;">remote API 程式</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># pip install pyzmq cbor
from zmqRemoteApi import RemoteAPIClient
import keyboard
import sim
import time
import simConst

print('Program started')
sim.simxFinish(-1) # just in case, close all openㄋed connections
clientID=sim.simxStart('192.168.1.35',19997,True,True,5000,5)
sim.simxStartSimulation(clientID, sim.simx_opmode_oneshot_wait)

if clientID!=-1:
    print('Connected to remote API server')
else:
    print('Failed connecting to remote API server')

print('Simulation started')

errorCode, leftMotor = sim.simxGetObjectHandle(clientID, 'leftMotor', sim.simx_opmode_oneshot_wait)
errorCode, rightMotor = sim.simxGetObjectHandle(clientID, 'rightMotor', sim.simx_opmode_oneshot_wait)

def setBubbleRobVelocity(leftWheelVelocity, rightWheelVelocity):
    errorCode, leftMotor = sim.simxGetObjectHandle(clientID, '/leftMotor', sim.simx_opmode_oneshot_wait)
    errorCode, rightMotor = sim.simxGetObjectHandle(clientID, '/rightMotor',sim.simx_opmode_oneshot_wait)
    sim.simxSetJointTargetVelocity(clientID, leftMotor, leftWheelVelocity, simConst.simx_opmode_streaming)
    sim.simxSetJointTargetVelocity(clientID, rightMotor, rightWheelVelocity, simConst.simx_opmode_streaming)

'''
# Example usage 1:
setBubbleRobVelocity(1.0, 1.0)
time.sleep(2)
setBubbleRobVelocity(0.0, 0.0)
'''
# use keyborad to move BubbleRob

while True:
    if keyboard.is_pressed('w'):
        setBubbleRobVelocity(2.0, 2.0)
    elif keyboard.is_pressed('s'):
        setBubbleRobVelocity(-2.0, -2.0)
    elif keyboard.is_pressed('a'):
        setBubbleRobVelocity(-2.0, 2.0)
    elif keyboard.is_pressed('d'):
        setBubbleRobVelocity(2.0, -2.0)
    elif keyboard.is_pressed('q'):
        # stop simulation
        sim.stopSimulation()
    else:
        setBubbleRobVelocity(0.0, 0.0)</pre>
<p><span style="background-color: #00ffff;"><span style="background-color: #ffffff;"></span></span></p>
<p><span style="background-color: #00ffff;"><span style="background-color: #ffffff;">控制 remote API 檔案：<a href="/downloads/bubbleRob_zmq_green_red_example.7z">bubbleRob_zmq_green_red_example.7z</a></span></span></p>
<p><span style="background-color: #00ffff;"><span style="background-color: #ffffff;"><span>遇到問題：一開始本組是利用三台教室電腦及一台筆電，開始模擬時唯獨筆電無法操控 bubbleRob，後來發現網路必需都要連至同一個 Wi-Fi 才能 zmqRemoteAPI 的操控。</span></span></span></p>
<p>w10製作內容</p>
<div><span style="background-color: #00ff00;">更改及融入課程後的答案 由41023119 呂承劼製作<br/></span></div>
<div><span style="background-color: #00ffff;">1.What is zmqRemoteAPI, and how does it relate to CoppeliaSim?</span></div>
<div></div>
<div>answer：zmqRemoteAPI 是應用程序可以連接CoppeliaSim的幾種方式之一。<br/><br/>zmqRemoteAPI 允許從外部應用程序或遠程硬件（例如實際機器人、遠程計算機等）控制模擬（或模擬器本身）。它提供了所有API功能，這些功能也可以通過CoppeliaSim腳本使用：這包括所有常規API功能（即sim.-type函數），還包括所有API功能由插件提供（例如simOMPL。，simUI。*，simIK。*等），如果啟用的狀況下。<br/><br/>zmqRemoteAPI 函數通過 ZeroMQ 及其與 CoppeliaSim 和 zmqRemoteAPI 附加組件的接口插件與CoppeliaSim 進行交互。所有這些都是對用戶隱藏的。遠程API可以讓一個或多個外部應用程序以步進方式（即與每個模擬步驟同步）或非步進方式（即正常操作模式）與CoppeliaSim交互，甚至支持遠程控制模擬器（例如，遠程加載場景，開始、暫停或停止模擬）。<br/><br/>請參閱programming/zmqRemoteApi文件夾或其相關存儲庫以獲取示例。</div>
<div>參考：<a href="https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm">https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm</a></div>
<div></div>
<div><span style="background-color: #00ffff;">2.How do you establish a connection between a Python script and CoppeliaSim using zmqRemoteAPI?</span></div>
<div><span style="background-color: #00ffff;"></span></div>
<div>answer：必須先導入 ZeroMQ 和 CBOR</div>
<div>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">$ /path/to/python -m pip install pyzmq
$ /path/to/python -m pip install cbor</pre>
<p>將 Python 遠端 API 項目的位置添加到 Python 的 sys.path 或 PYTHONPATH 環境變量中也會很有幫助。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">$ export PYTHONPATH=/path/to/zmqRemoteApi/clients/python</pre>
<p>以下是一個非常簡單的 ZeroMQ 遠端 API 客戶端代碼示例，它會啟動模擬器並運行一個 3 秒的步進模擬：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import time
from zmqRemoteApi import RemoteAPIClient

client = RemoteAPIClient()
sim = client.getObject('sim')

client.setStepping(True)

sim.startSimulation()
while (t := sim.getSimulationTime()) &lt; 3:
    s = f'Simulation time: {t:.2f} [s]'
    print(s)
    client.step()
sim.stopSimulation()</pre>
<p>參考：<a href="https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm">https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm</a><br/><br/></p>
</div>
<div><span style="background-color: #00ffff;">3.What are some common use cases for zmqRemoteAPI in CoppeliaSim?</span></div>
<div><span style="background-color: #00ffff;"></span></div>
<div>answer：以下是從 CoppeliaSim 資料夾所提供的示範程式<span style="background-color: #00ffff;"></span></div>
<div>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># Make sure to have the server side running in CoppeliaSim:
# in a child script of a CoppeliaSim scene, add following command
# to be executed just once, at simulation start:
#
# simRemoteApi.start(19999)
#
# then start simulation, and run this program.
#
# IMPORTANT: for each successful call to simxStart, there
# should be a corresponding call to simxFinish at the end!

try:
    import sim
except:
    print ('--------------------------------------------------------------')
    print ('"sim.py" could not be imported. This means very probably that')
    print ('either "sim.py" or the remoteApi library could not be found.')
    print ('Make sure both are in the same folder as this file,')
    print ('or appropriately adjust the file "sim.py"')
    print ('--------------------------------------------------------------')
    print ('')

import time

print ('Program started')
sim.simxFinish(-1) # just in case, close all opened connections
clientID=sim.simxStart('192.168.56.1',19997,True,True,5000,5) # Connect to CoppeliaSim
if clientID!=-1:
    print ('Connected to remote API server')

    # Now try to retrieve data in a blocking fashion (i.e. a service call):
    res,objs=sim.simxGetObjects(clientID,sim.sim_handle_all,sim.simx_opmode_blocking)
    if res==sim.simx_return_ok:
        print ('Number of objects in the scene: ',len(objs))
    else:
        print ('Remote API function call returned with error code: ',res)

    time.sleep(2)

    # Now retrieve streaming data (i.e. in a non-blocking fashion):
    startTime=time.time()
    sim.simxGetIntegerParameter(clientID,sim.sim_intparam_mouse_x,sim.simx_opmode_streaming) # Initialize streaming
    while time.time()-startTime &lt; 1:
        returnCode,data=sim.simxGetIntegerParameter(clientID,sim.sim_intparam_mouse_x,sim.simx_opmode_buffer) # Try to retrieve the streamed data
        if returnCode==sim.simx_return_ok: # After initialization of streaming, it will take a few ms before the first value arrives, so check the return code
            print ('Mouse position x: ',data) # Mouse position x is actualized when the cursor is over CoppeliaSim's window
        time.sleep(0.005)

    # Now send some data to CoppeliaSim in a non-blocking fashion:
    sim.simxAddStatusbarMessage(clientID,'這個 Python remote API 將會連續執行 1 秒鐘, 歡迎進入 CoppeliaSim 的虛擬世界!',sim.simx_opmode_oneshot)

    # Before closing the connection to CoppeliaSim, make sure that the last command sent out had time to arrive. You can guarantee this with (for example):
    sim.simxGetPingTime(clientID)

    # Now close the connection to CoppeliaSim:
    sim.simxFinish(clientID)
else:
    print ('Failed connecting to remote API server')
print ('Program ended')</pre>
</div>
<div><span style="background-color: #00ffff;">4.What are the advantages and disadvantages of using zmqRemoteAPI compared to other methods of communication between Python and CoppeliaSim?</span></div>
<div><br/>answer：使用zmqRemoteAPI相比其他Python與CoppeliaSim之間的通訊方法，優點是可以讓使用者從外部應用程式或遠端硬體（如真實機器人、遠程電腦等）控制模擬（或模擬器本身），並提供了所有API函數，包括常規API函數和由插件提供的API函數（例如simOMPL、simUI、simIK等）。此外，使用zmqRemoteAPI可以讓一個或多個外部應用程式以同步或非同步方式與CoppeliaSim互動，甚至支持遠程控制模擬器。<br/><br/>缺點是使用zmqRemoteAPI需要較高的程式設計知識，而且需要較多的設置和配置才能建立連接。同時，使用zmqRemoteAPI也可能會對CoppeliaSim的效能產生一定的影響，因此在實現具體項目時需要仔細考慮使用zmqRemoteAPI是否適合。</div>
<div></div>
<div>以下是 Coppelia Robotics forums 中使用者在網站上提出的問題：<a href="https://forum.coppeliarobotics.com/viewtopic.php?t=9809">https://forum.coppeliarobotics.com/viewtopic.php?t=9809</a></div>
<div></div>
<div><span style="background-color: #00ffff;">5.Can you give an example of a project or task that you could complete using zmqRemoteAPI in CoppeliaSim?</span></div>
<div></div>
<div>answer：以下是在課程上利用 zmqRemoteAPI 在 CoppeliaSim 中完成四人連線控制機器人之影片</div>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/8Nqbb7NHTvE" title="YouTube video player" width="560"></iframe></p><h2>41023126</h2>
<p>5/1討論機械式計分器</p>
<p>有三種方式</p>
<p>第一種 使用凸輪機構</p>
<p><img alt="" height="377" src="/images/螢幕擷取畫面 2023-05-01 104445.png" width="683"/></p>
<p>資料圖片來源 :<a href="https://www.instructables.com/Mechanical-Digital-Clock/">https://www.instructables.com/Mechanical-Digital-Clock/</a></p>
<p>第二種 馬達直接傳動</p>
<p><img alt="" height="397" src="/images/螢幕擷取畫面 2023-05-01 104049.png" width="664"/></p>
<p>第三種 ㄇ型固定座 馬達</p>
<p></p>
<p><img alt="" height="363" src="/images/螢幕擷取畫面 2023-05-01 105427.png" width="642"/></p>
<p>5/6 設計出機械式記分板</p>
<p><img alt="" height="441" src="/images/記分板第一版-1.png" width="473"/></p>
<p>利用onshape 所繪製 連結網址:<a href="https://cad.onshape.com/documents/025ed0d2004ecc2f22856170/w/0cca45e995252e3db618a8c5/e/6a3fe3ab387ef63c13128863?renderMode=0&amp;uiState=6456702e8c7fe730de23047f">scoreboard 第一版</a></p>
<p>在coppeliasim中模擬放置</p>
<p><img alt="" height="434" src="/images/記分板第一版-3.png" width="578"/></p><h2>41023138</h2>
<p>w10</p>
<p>問題:What are the advantages and disadvantages of using zmqRemoteAPI compared to other methods of communication between Python and CoppeliaSim?</p>
<p>answer:</p>
<div><span>優點：</span></div>
<div><span>跨平台：zmqRemoteAPI基於ZeroMQ庫實現，支持跨平台通信，因此可以輕鬆地在Windows、Mac和Linux等操作系統上使用。</span></div>
<div><span>高效性：zmqRemoteAPI的通信速度非常快，比其他通信方法如socket和pipe等更加高效，這對於需要快速傳輸大量數據的應用場景非常有利。</span></div>
<div><span>易於使用：使用zmqRemoteAPI進行通信非常簡單，只需要在Python腳本中導入相關庫，創建一個ZeroMQ套接字並與CoppeliaSim建立連接即可。 設置靈活：zmqRemoteAPI的設置非常靈活，可以根據需要對其進行自定義設置，例如可以設置超時時間、心跳機制等。</span></div>
<div><span>缺點：</span></div>
<div><span>依賴庫較多：使用zmqRemoteAPI需要安裝和導入多個庫，包括zmq庫和zmqRemoteAPI庫，這增加了開發和維護的複雜度。</span></div>
<div><span>需要CoppeliaSim的支持：zmqRemoteAPI需要CoppeliaSim進行支持，因此需要在CoppeliaSim的腳本中進行相應的設置。</span></div>
<div><span>總的來說，使用zmqRemoteAPI作為Python和CoppeliaSim之間通信的方法具有許多優點，但也存在一些缺點。開發者可以根據具體應用場景選擇最適合的通信方式。</span></div>
<p></p>
<h1>w10</h1>
<div>
<div>有關 CoppeliaSim zmqRemoteAPI 問題</div>
<div data-tid="messageBodyContainer">
<div data-tid="messageBodyContent">
<ol>
<li>What is zmqRemoteAPI, and how does it relate to CoppeliaSim?</li>
<li>How do you establish a connection between a Python script and CoppeliaSim using zmqRemoteAPI?</li>
<li>What are some common use cases for zmqRemoteAPI in CoppeliaSim?</li>
<li>What are the advantages and disadvantages of using zmqRemoteAPI compared to other methods of communication between Python and CoppeliaSim?</li>
<li>Can you give an example of a project or task that you could complete using zmqRemoteAPI in CoppeliaSim?</li>
</ol>
<div>有關 CoppeliaSim zmqRemoteAPI 問題 中文翻譯</div>
<div>
<ol>
<li>
<p>zmqRemoteAPI是什麼，它如何與CoppeliaSim相關聯？</p>
</li>
<li>
<p>如何使用zmqRemoteAPI在Python腳本和CoppeliaSim之間建立連接？ </p>
</li>
<li>
<p>在CoppeliaSim中，zmqRemoteAPI的常見用途是什麼？</p>
</li>
<li>
<p>使用zmqRemoteAPI相對於其他Python和CoppeliaSim之間的通信方法有什麼優點和缺點？ </p>
</li>
<li>
<p>能否舉一個使用zmqRemoteAPI在CoppeliaSim中完成的項目或任務的例子？ </p>
</li>
</ol>
</div>
<div></div>
<div>answer:</div>
<div></div>
<div><span style="background-color: #00ff00;"><strong>41023114&gt;1</strong></span></div>
<div><span>zmqRemoteAPI</span><span> </span><span>是</span><span> </span><span>CoppeliaSim</span><span> </span><span>提供的一個用於遠端控制仿真場景的工具。它基於</span><span> </span><span>ZeroMQ</span><span> </span><span>庫實現，可以在</span><span> </span><span>Python、MATLAB、C++、Java、Octave</span><span> </span><span>等多種編程語言中使用。使用</span><span> </span><span>zmqRemoteAPI，可以通過編程控制</span><span> </span><span>CoppeliaSim</span><span> </span><span>中的機器人、傳感器、物體等各種元件，實現自動化控制、遠端操作、仿真驗證等功能。 因此，zmqRemoteAPI</span><span> </span><span>是</span><span> </span><span>CoppeliaSim</span><span> </span><span>中的一個重要功能，使得使用者可以通過編程方式控制和操作仿真場景中的各種元件，進而實現更加靈活和高效的仿真操作。</span></div>
<div><span></span></div>
<div><span style="background-color: #00ff00;"><strong>41023119&gt;2</strong></span></div>
<div><span>1.在</span><span> </span><span>Python</span><span> </span><span>程式中，使用相應的</span><span> </span><span>Python</span><span> </span><span>模組（例如</span><span> </span><span>PyZMQ）引入</span><span> </span><span>zmqRemoteAPI。 </span></div>
<div><span>2.在</span><span> </span><span>CoppeliaSim</span><span> </span><span>模擬環境中，添加一個</span><span> </span><span>Remote</span><span> </span><span>API</span><span> </span><span>Server</span><span> </span><span>對象，並設定相應的通訊端口。 在</span><span> </span><span>Python</span><span> </span><span>程式中，使用</span><span> </span><span>zmqRemoteAPI</span><span> </span><span>提供的函式（例如</span><span> </span><span>simxStart、simxFinish、simxGetConnectionId</span><span> </span><span>等）建立與</span><span> </span><span>CoppeliaSim</span><span> </span><span>的連接，並設定適當的連接參數。 </span></div>
<div><span>3.通過</span><span> </span><span>zmqRemoteAPI</span><span> </span><span>提供的函式（例如</span><span> </span><span>simxCallScriptFunction、simxGetObjectHandle</span><span> </span><span>等）向</span><span> </span><span>CoppeliaSim</span><span> </span><span>發送指令或獲取資料。 </span></div>
<div><span>4.在</span><span> </span><span>Python</span><span> </span><span>程式中，使用</span><span> </span><span>zmqRemoteAPI</span><span> </span><span>提供的函式（例如</span><span> </span><span>simxFinish）關閉與</span><span> </span><span>CoppeliaSim</span><span> </span><span>的連接。 簡而言之，使用</span><span> </span><span>zmqRemoteAPI</span><span> </span><span>在</span><span> </span><span>Python</span><span> </span><span>和</span><span> </span><span>CoppeliaSim</span><span> </span><span>之間建立連接需要在</span><span> </span><span>Python</span><span> </span><span>程式中引入相應的模組、設定</span><span> </span><span>CoppeliaSim</span><span> </span><span>的</span><span> </span><span>Remote</span><span> </span><span>API</span><span> </span><span>Server、使用相應的函式建立連接、進行通訊和控制，並在連接結束時關閉連接。</span></div>
<div><span></span></div>
<div><strong><span style="background-color: #00ff00;">41023126&gt;3</span></strong></div>
<div>zmqRemoteAPI 在 CoppeliaSim 中的一些常見使用案例：<br/>控制機器人：使用 zmqRemoteAPI 可以通過 Python 程式控制 CoppeliaSim 中的機器人模型，例如移動機器人、控制關節運動、設定感測器等。<br/>場景設置：使用 zmqRemoteAPI 可以自動化設置 CoppeliaSim 中的場景，例如添加物體、設定物體的位置和屬性、設置環境條件等。<br/>效能測試：使用 zmqRemoteAPI 可以進行性能測試和評估，例如測試控制算法的運行速度、記憶體使用等。<br/>資料收集：使用 zmqRemoteAPI 可以從 CoppeliaSim 中獲取模擬環境中的資料，例如感測器數值、物體位置、碰撞狀態等，並用於後續的資料分析和處理。<br/>教育和研究：使用 zmqRemoteAPI 可以在教育和研究領域中進行虛擬實驗、模擬場景等，幫助學生和研究人員學習和研究機器人相關的知識和技能。<br/>簡而言之，zmqRemoteAPI 在 CoppeliaSim 中常見的使用案例包括機器人控制、場景設置、效能測試、資料收集和教育研究等領域。</div>
<div></div>
<div><strong><span style="background-color: #00ff00;">41023138&gt;4</span></strong></div>
<div><span>優點： </span></div>
<div><span>跨平台：zmqRemoteAPI基於ZeroMQ庫實現，支持跨平台通信，因此可以輕鬆地在Windows、Mac和Linux等操作系統上使用。 </span></div>
<div><span>高效性：zmqRemoteAPI的通信速度非常快，比其他通信方法如socket和pipe等更加高效，這對於需要快速傳輸大量數據的應用場景非常有利。 </span></div>
<div><span>易於使用：使用zmqRemoteAPI進行通信非常簡單，只需要在Python腳本中導入相關庫，創建一個ZeroMQ套接字並與CoppeliaSim建立連接即可。 設置靈活：zmqRemoteAPI的設置非常靈活，可以根據需要對其進行自定義設置，例如可以設置超時時間、心跳機制等。 </span></div>
<div><span>缺點： </span></div>
<div><span>依賴庫較多：使用zmqRemoteAPI需要安裝和導入多個庫，包括zmq庫和zmqRemoteAPI庫，這增加了開發和維護的複雜度。 </span></div>
<div><span>需要CoppeliaSim的支持：zmqRemoteAPI需要CoppeliaSim進行支持，因此需要在CoppeliaSim的腳本中進行相應的設置。 </span></div>
<div><span>總的來說，使用zmqRemoteAPI作為Python和CoppeliaSim之間通信的方法具有許多優點，但也存在一些缺點。開發者可以根據具體應用場景選擇最適合的通信方式。</span></div>
<div><span></span></div>
<div><strong><span style="background-color: #00ff00;">41023114&gt;5</span></strong></div>
<div><span>以下是一個使用</span><span> </span><span>CoppeliaSim</span><span> </span><span>的</span><span> </span><span>zmqRemoteAPI</span><span> </span><span>控制機械臂自動抓取物體的</span><span> </span><span>Python</span><span> </span><span>程序 </span></div>
<div>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sim import time # 定義物體的名稱和位置
object_name = 'Cuboid' object_position = [-0.2, 0.5, 0.1] # 連接 CoppeliaSim sim.simxFinish(-1) clientID = sim.simxStart('127.0.0.1', 19999, True, True, 5000, 5) 
if clientID != -1: print('Connected to remote API server') # 取得機械臂控制句柄
errorCode, robot_handle = sim.simxGetObjectHandle(clientID, 'UR3', sim.simx_opmode_blocking) # 取得物體控制句柄
errorCode, object_handle = sim.simxGetObjectHandle(clientID, object_name, sim.simx_opmode_blocking) # 移動機械臂到指定位置
target_position = [-0.2, 0.5, 0.2] sim.simxSetObjectPosition(clientID, robot_handle, -1, target_position, sim.simx_opmode_blocking) # 機械臂夾取物體 sim.simxSetObjectParent(clientID, object_handle, robot_handle, True, sim.simx_opmode_blocking) # 移動機械臂到指定位置
sim.simxSetObjectPosition(clientID, robot_handle, -1, object_position, sim.simx_opmode_blocking) # 釋放夾爪
sim.simxSetObjectParent(clientID, object_handle, -1, True, sim.simx_opmode_blocking) # 移動機械臂到指定位置
sim.simxSetObjectPosition(clientID, robot_handle, -1, target_position, sim.simx_opmode_blocking) # 斷開與 CoppeliaSim 的連接
sim.simxFinish(clientID) else: print('Failed connecting to remote API server') time.sleep(1)</pre>
</div>
<div><span> 這個</span><span> </span><span>Python</span><span> </span><span>程序通過</span><span> </span><span>CoppeliaSim</span><span> </span><span>的</span><span> </span><span>zmqRemoteAPI</span><span> </span><span>連接到</span><span> </span><span>CoppeliaSim</span><span> </span><span>仿真環境，控制機械臂移動到指定位置，夾取物體並將其移動到另一個位置，最後釋放夾爪。這個程序可以應用於機械臂自動化抓取和放置物體的項目或任務。</span><span> </span></div>
<div><span></span></div>
<div><span style="background-color: #00ff00;">更改及融入課程後的答案 由41023119 呂承劼製作<br/></span></div>
<div><span style="background-color: #00ffff;">1.What is zmqRemoteAPI, and how does it relate to CoppeliaSim?</span></div>
<div></div>
<div>answer：zmqRemoteAPI 是應用程序可以連接CoppeliaSim的幾種方式之一。<br/><br/>zmqRemoteAPI 允許從外部應用程序或遠程硬件（例如實際機器人、遠程計算機等）控制模擬（或模擬器本身）。它提供了所有API功能，這些功能也可以通過CoppeliaSim腳本使用：這包括所有常規API功能（即sim.-type函數），還包括所有API功能由插件提供（例如simOMPL。，simUI。*，simIK。*等），如果啟用的狀況下。<br/><br/>zmqRemoteAPI 函數通過 ZeroMQ 及其與 CoppeliaSim 和 zmqRemoteAPI 附加組件的接口插件與CoppeliaSim 進行交互。所有這些都是對用戶隱藏的。遠程API可以讓一個或多個外部應用程序以步進方式（即與每個模擬步驟同步）或非步進方式（即正常操作模式）與CoppeliaSim交互，甚至支持遠程控制模擬器（例如，遠程加載場景，開始、暫停或停止模擬）。<br/><br/>請參閱programming/zmqRemoteApi文件夾或其相關存儲庫以獲取示例。</div>
<div>參考：<a href="https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm">https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm</a></div>
<div></div>
<div><span style="background-color: #00ffff;">2.How do you establish a connection between a Python script and CoppeliaSim using zmqRemoteAPI?</span></div>
<div><span style="background-color: #00ffff;"></span></div>
<div>answer：必須先導入 ZeroMQ 和 CBOR</div>
<div>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">$ /path/to/python -m pip install pyzmq
$ /path/to/python -m pip install cbor</pre>
<p>將 Python 遠端 API 項目的位置添加到 Python 的 sys.path 或 PYTHONPATH 環境變量中也會很有幫助。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">$ export PYTHONPATH=/path/to/zmqRemoteApi/clients/python</pre>
<p>以下是一個非常簡單的 ZeroMQ 遠端 API 客戶端代碼示例，它會啟動模擬器並運行一個 3 秒的步進模擬：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import time
from zmqRemoteApi import RemoteAPIClient

client = RemoteAPIClient()
sim = client.getObject('sim')

client.setStepping(True)

sim.startSimulation()
while (t := sim.getSimulationTime()) &lt; 3:
    s = f'Simulation time: {t:.2f} [s]'
    print(s)
    client.step()
sim.stopSimulation()</pre>
<p>參考：<a href="https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm">https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm</a><br/><br/></p>
</div>
<div><span style="background-color: #00ffff;">3.What are some common use cases for zmqRemoteAPI in CoppeliaSim?</span></div>
<div><span style="background-color: #00ffff;"></span></div>
<div>answer：以下是從 CoppeliaSim 資料夾所提供的示範程式<span style="background-color: #00ffff;"></span></div>
<div>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># Make sure to have the server side running in CoppeliaSim:
# in a child script of a CoppeliaSim scene, add following command
# to be executed just once, at simulation start:
#
# simRemoteApi.start(19999)
#
# then start simulation, and run this program.
#
# IMPORTANT: for each successful call to simxStart, there
# should be a corresponding call to simxFinish at the end!

try:
    import sim
except:
    print ('--------------------------------------------------------------')
    print ('"sim.py" could not be imported. This means very probably that')
    print ('either "sim.py" or the remoteApi library could not be found.')
    print ('Make sure both are in the same folder as this file,')
    print ('or appropriately adjust the file "sim.py"')
    print ('--------------------------------------------------------------')
    print ('')

import time

print ('Program started')
sim.simxFinish(-1) # just in case, close all opened connections
clientID=sim.simxStart('192.168.56.1',19997,True,True,5000,5) # Connect to CoppeliaSim
if clientID!=-1:
    print ('Connected to remote API server')

    # Now try to retrieve data in a blocking fashion (i.e. a service call):
    res,objs=sim.simxGetObjects(clientID,sim.sim_handle_all,sim.simx_opmode_blocking)
    if res==sim.simx_return_ok:
        print ('Number of objects in the scene: ',len(objs))
    else:
        print ('Remote API function call returned with error code: ',res)

    time.sleep(2)

    # Now retrieve streaming data (i.e. in a non-blocking fashion):
    startTime=time.time()
    sim.simxGetIntegerParameter(clientID,sim.sim_intparam_mouse_x,sim.simx_opmode_streaming) # Initialize streaming
    while time.time()-startTime &lt; 1:
        returnCode,data=sim.simxGetIntegerParameter(clientID,sim.sim_intparam_mouse_x,sim.simx_opmode_buffer) # Try to retrieve the streamed data
        if returnCode==sim.simx_return_ok: # After initialization of streaming, it will take a few ms before the first value arrives, so check the return code
            print ('Mouse position x: ',data) # Mouse position x is actualized when the cursor is over CoppeliaSim's window
        time.sleep(0.005)

    # Now send some data to CoppeliaSim in a non-blocking fashion:
    sim.simxAddStatusbarMessage(clientID,'這個 Python remote API 將會連續執行 1 秒鐘, 歡迎進入 CoppeliaSim 的虛擬世界!',sim.simx_opmode_oneshot)

    # Before closing the connection to CoppeliaSim, make sure that the last command sent out had time to arrive. You can guarantee this with (for example):
    sim.simxGetPingTime(clientID)

    # Now close the connection to CoppeliaSim:
    sim.simxFinish(clientID)
else:
    print ('Failed connecting to remote API server')
print ('Program ended')</pre>
</div>
<div><span style="background-color: #00ffff;">4.What are the advantages and disadvantages of using zmqRemoteAPI compared to other methods of communication between Python and CoppeliaSim?</span></div>
<div><br/>answer：使用zmqRemoteAPI相比其他Python與CoppeliaSim之間的通訊方法，優點是可以讓使用者從外部應用程式或遠端硬體（如真實機器人、遠程電腦等）控制模擬（或模擬器本身），並提供了所有API函數，包括常規API函數和由插件提供的API函數（例如simOMPL、simUI、simIK等）。此外，使用zmqRemoteAPI可以讓一個或多個外部應用程式以同步或非同步方式與CoppeliaSim互動，甚至支持遠程控制模擬器。<br/><br/>缺點是使用zmqRemoteAPI需要較高的程式設計知識，而且需要較多的設置和配置才能建立連接。同時，使用zmqRemoteAPI也可能會對CoppeliaSim的效能產生一定的影響，因此在實現具體項目時需要仔細考慮使用zmqRemoteAPI是否適合。</div>
<div></div>
<div>以下是 Coppelia Robotics forums 中使用者在網站上提出的問題：<a href="https://forum.coppeliarobotics.com/viewtopic.php?t=9809">https://forum.coppeliarobotics.com/viewtopic.php?t=9809</a></div>
<div></div>
<div><span style="background-color: #00ffff;">5.Can you give an example of a project or task that you could complete using zmqRemoteAPI in CoppeliaSim?</span></div>
<div></div>
<div>answer：以下是在課程上利用 zmqRemoteAPI 在 CoppeliaSim 中完成四人連線控制機器人之影片</div>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/8Nqbb7NHTvE" title="YouTube video player" width="560"></iframe></p>
<div></div>
<div><span>meeting</span></div>
<div><span></span></div>
<div><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/DVIoMEVhI7k" width="560"></iframe></span><span></span></div>
</div>
</div>
</div><h1>note</h1>
<p>課程筆記</p>
<h2>stud2.cycu.org</h2>
<p>資料連結:<a href="https://teams.microsoft.com/_#/school/ClassNotes/w5?threadId=19:a398eb1b5dc841b690f68a4e4dcefdb7@thread.tacv2&amp;ctx=channel">team-cad2022-w5</a></p>
<p>step 1：Login to https://mail.nfu.edu.tw - 查看登入 stud2.cycu.org 伺服器的密碼, 帳號為 cd+學號, 密碼為四個字元, 包括數字與小寫英文字母，並查詢 stud.cycu.org 中與帳號對應的近端 (給 127.0.0.1 使用, 9 開頭的 port) 與遠端 (給 stud.cycu.org, 8 開頭的 port) 埠號 <br/>step 2：修改可攜 Python 3.10.6 start.bat, 蓋掉第三行後重新啟動, 目的希望將操作系統的命令搜尋路徑放在可攜目錄搜尋路徑之後. <br/>step 3：重新啟動可攜程式環境, 在其中一個命令列, ssh  cd+學號@stud2.cycu.org, 表示要使用 secure shell 遠端登入到 stud2.cycu.org, 這是一台 Linux 主機, 安裝 Ubuntu 22.04 Server.(若使用的網路連線協定並無 IPv6,  可將系統的 proxy 設為 140.130.17.4:3128 kmolab/kmolab) <br/>step 4：在 ssh 登入畫面, 以 ssh-keygen 建立 key pairs, .ssh/id_rsa 為 private key, id_rsa.pub 為 public key <br/>step 5：設法利用 Filezilla, 以 sftp 安全的(Secure)檔案(File)傳輸(Transmission)協定(Protocol), 與 stud.cycu.org 伺服器連結. <br/>step 6：利用  Filezilla sftp 取下 id_rsa.pub, 登錄至 Github 帳號下的 Setting - &gt;  SSH and GPG keys. <br/>step 7：對 server sftp 也可以利用  Filezilla portable, 以圖形介面完成. 而 ssh 也可以透過  putty.exe 執行遠端登入. <br/>step 8：接下來要下載  config 設定檔案,  以 sftp 放入 stud2.cycu.org 主機的 .ssh 目錄中. <br/>step 9：接下來要在  Ubuntu (也就是 stud.cycu.org 這台主機所安裝的操作系統) 中, 設定 .gitconfig, 總共包含三項設定: git config --global user.name "scrum-1", git config --global user.email  "scrum1@mde.tw"   以及 git config --global http.proxy http://p42.cycu.org:3128, 這三個設定必須在 ssh 登入畫面中執行, 設定完成檔案會存入帳號根目錄中的 .gitconfig  <br/>step 10：接著下載 server.py, 在 Windows 編輯 server.py, 將個人分配到的 9xxxx 埠號填入後存檔, 以 sftp 放入上列取下的倉儲根目錄. <br/>會使用的指令：<br/>pwd 代表 print working directory, clear - 清除螢幕<br/>cd - 更換目錄<br/>ls -l - 列出目錄詳細內容<br/>chmod u+x acp - 表示讓 user 可以 execute acp script (能夠讓使用者以 source acp 加上提交字串進行 git add, git commit, git push, 如何在 Windows 執行 acp.bat 加上提交字串. <br/>ps axo pid,comm,user | grep "python3" - 表示要找出使用 python3 執行的 process, 列出其 process id, command 以及 user<br/>kill -9 - 移除 python3 執行的 process id</p>
<h1>progress</h1>
<p><strong><span style="background-color: #ffff00;">week10</span>：</strong>製作、討論四人連線控制機器人之專案、回答 w10 之問題</p>
<p><strong>41023114</strong></p>
<p><strong>41023119</strong></p>
<p>製作四人連線機器人之場景</p>
<p>加入 pj2、加入 w10、修改 w10 回答</p>
<p><strong>41023126</strong></p>
<p>加入<span>pj2、 w10的問題回答</span></p>
<p><strong>41023138</strong></p>
<p>加入 pj2、w10、修改 w10 問題回答</p>
<p><strong><span style="background-color: #ffff00;">week11</span>：</strong>製作足球場景之計時器</p>
<p><strong>41023114</strong></p>
<p><strong>41023119</strong></p>
<p>設計顏色計分板及編寫記分板程式</p>
<p><strong>41023126</strong></p>
<p>提出計時器之變動機構設計</p>
<p>設計出機械式計分板第一版</p>
<p><strong>41023138</strong></p><h1>Brython</h1>
<p><a href="https://en.wikipedia.org/wiki/Python_(programming_language)">https://en.wikipedia.org/wiki/Python_(programming_language)</a></p>
<h4>Examples:</h4>
<p style="padding-left: 30px;"><a href="https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d">https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d</a></p>
<p style="padding-left: 30px;"><a href="https://www.geeksforgeeks.org/python-programming-examples/">https://www.geeksforgeeks.org/python-programming-examples/</a></p>
<p style="padding-left: 30px;"><a href="https://www.programiz.com/python-programming/examples">https://www.programiz.com/python-programming/examples</a></p>
<p style="padding-left: 30px;"><a href="https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/">https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/</a></p>
<h4>Python Tutorial:</h4>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/">https://docs.python.org/3/tutorial/</a></p>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/introduction.html">An informal introduction to Python</a></p>
<h4>Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍)</h4>
<h4>Variables (<a href="https://github.com/python/cpython/blob/3.11/Lib/keyword.py">Python Keywords</a>)</h4>
<h4>Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解)</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#numbers">Numbers</a> (整數 int(), 浮點數 float())</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#strings">Strings</a> (字串)</h4>
<h4>print (Python 內建函式, <a href="https://docs.python.org/3/library/functions.html#print">print()</a> 函式)</h4>
<p><a href="https://docs.python.org/3/tutorial/controlflow.html">Python control flow tools</a></p>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#for-statements">for</a></h4>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#if-statements">if</a></h4>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#the-range-function">range</a></h4>
<h4>open</h4>
<h4>read</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#lists">lists</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">tuples</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionaries</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">functions</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/errors.html#exceptions">try ... except</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops">break</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#pass-statements">pass</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/classes.html?highlight=classes">classes</a></h4>
<p>這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 (<a href="/downloads/practice_html.txt">practice_html.txt</a> 動態頁面超文件).</p>
<p><a href="/downloads/practice_html.txt">practice_html.txt</a> 動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用.</p>
<p>亦即將所有對應的 html 也使用 Brython 產生, 然後寫為 <a href="https://docs.python.org/3/tutorial/classes.html">class</a> 後, 在範例導入時透過 <a href="https://docs.python.org/3/tutorial/classes.html#instance-objects">instance</a> 引用.</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
&lt;/script&gt;</pre>
<p>從 1 累加到 100:</p>
<p><button id="add1to100">1 add to 100</button></p>
<p>將 iterable 與 iterator <a href="https://home.gamer.com.tw/creationDetail.php?sn=4337438">相關說明</a>, 利用 Brython 與 Ace Editor 整理在這個頁面.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"><!-- 導入 brython 程式庫 --></pre>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"><!-- 啟動 Brython --></pre>
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"><!-- editor1 開始 --></pre>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"><!-- editor1 結束 --></pre>
<hr/>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"><!-- ########################################## --></pre>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button><button id="threejsblock">Rotating Block</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
################################## threejsblock start
threejsblock_url = "https://gist.githubusercontent.com/mdecycu/2c6323eff49b496d1bafd210f3ec9707/raw/df37802f9e8a386b6424f7945af622b1cd0a9ca5/threejs_rotating_block.py"
threejsblock = button2(threejsblock_url)
doc["threejsblock"].bind("click", threejsblock.do)
################################## threejsblock end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"><!-- editor2 開始 --></pre>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"><!-- editor2 結束 --></pre>
<hr/>
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>
<h2>Brython_ex2</h2>
<p>This code uses the Euler method to approximate the solution to the ODE dy/dx = x - y with an initial condition of y0 = 1.0. The solution is calculated for a range of x values from 0 to 5.</p>
<p id="brython_div"></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</pre>
<p>Solve ODE:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document

def dy_dx(y, x):
    return x - y

x_start = 0
x_end = 5
n_points = 100
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = 1.0
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))

# Create a new paragraph element and set its text content to the solution
p = document.createElement('p')
p.textContent = f"The solution to the ODE is: {y}"

# Append the paragraph element to the body of the webpage
document.body.appendChild(p)</pre>
<p></p>
<p>
<script type="text/python3">
from browser import document, window

def dy_dx(y, x):
    return x - y

x_start = 0
x_end = 5
n_points = 100
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = 1.0
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))

# Create a new div element to hold the plot
#plot_div = document.createElement('div')
#plot_div.id = 'plot'
#document.body.appendChild(plot_div)
plot_div = document["brython_div"]

# Plot the solution using plotly.js
data = [{'x': x, 'y': y}]
window.Plotly.newPlot('brython_div', data)
</script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</p>
<p>Brython environment and <a href="https://plotly.com/javascript/">Plotly.js</a>:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;script src="/static/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;script&gt;// &lt;![CDATA[
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
// ]]&gt;&lt;/script&gt;
&lt;p id="brython_div"&gt;&lt;/p&gt;</pre>
<p>Brython programe with Plotly.js:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, window

def dy_dx(y, x):
    return x - y

x_start = 0
x_end = 5
n_points = 100
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = 1.0
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))

# Create a new div element to hold the plot
#plot_div = document.createElement('div')
#plot_div.id = 'plot'
#document.body.appendChild(plot_div)
plot_div = document["brython_div"]

# Plot the solution using plotly.js
data = [{'x': x, 'y': y}]
window.Plotly.newPlot('brython_div', data)</pre>
<p>This code defines a function dy_dx that represents the mass-spring-damper ordinary differential equation. The Euler method is used to solve this equation for a range of x values from 0 to 20 with initial conditions of y0 = [1.0, 0.0]. The solution is then plotted on the webpage using <a href="https://plotly.com/javascript/">plotly.js</a>.</p>
<p id="mass-spring-damper"></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">
<script type="text/python3">
from browser import document, window

m = 1.0  # mass
k = 1.0  # spring constant
c = 0.1  # damping coefficient

def dy_dx(y, x):
    y1, y2 = y
    return [y2, -(k/m)*y1 - (c/m)*y2]

x_start = 0
x_end = 20
n_points = 1000
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = [1.0, 0.0]
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y_new = [y[-1][j] + h * dy_dx(y[-1], x[i-1])[j] for j in range(2)]
    y.append(y_new)

# Create a new div element to hold the plot
'''
plot_div = document.createElement('div')
plot_div.id = 'plot'
document.body.appendChild(plot_div)
'''

# Plot the solution using plotly.js
data = [{'x': x, 'y': [y[i][0] for i in range(len(y))]}]
layout = {'title': 'Mass-Spring-Damper System', 'xaxis': {'title': 'Time'}, 'yaxis': {'title': 'Displacement'}}
window.Plotly.newPlot('mass-spring-damper', data, layout)
</script>
</pre>
<p>This code defines a function dy_dx that represents the mass-spring-damper system with a PID controller. The gains of the PID controller are set to Kp = 10.0, Ki = 1.0, and Kd = 0.5. The Euler method is used to solve this system of equations for a range of x values from 0 to 20 with initial conditions of y0 = [0.0, 0.0, 0.0, 0.0]. The response of the system is then plotted on the webpage using <a href="https://plotly.com/javascript/">plotly.js</a>.</p>
<p id="pid-control"></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">
<script type="text/python3">
from browser import document, window

m = 1.0  # mass
k = 1.0  # spring constant
c = 0.1  # damping coefficient

Kp = 10.0  # proportional gain
Ki = 1.0   # integral gain
Kd = 0.5   # derivative gain

def dy_dx(y, x):
    y1, y2, e_int, e_prev = y
    e = 1 - y1
    de_dt = -y2
    u = Kp * e + Ki * e_int + Kd * de_dt
    return [y2, (u - k*y1 - c*y2)/m, e, e]

x_start = 0
x_end = 20
n_points = 1000
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = [0.0, 0.0, 0.0, 0.0]
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y_new = [y[-1][j] + h * dy_dx(y[-1], x[i-1])[j] for j in range(4)]
    y.append(y_new)

'''
# Create a new div element to hold the plot
plot_div = document.createElement('div')
plot_div.id = 'plot'
document.body.appendChild(plot_div)
'''

# Plot the solution using plotly.js
data = [{'x': x, 'y': [y[i][0] for i in range(len(y))], 'name': 'Output'},
        {'x': x, 'y': [1 for _ in range(len(y))], 'name': 'Setpoint'}]
layout = {'title': 'Mass-Spring-Damper System with PID Control', 'xaxis': {'title': 'Time'}, 'yaxis': {'title': 'Displacement'}}
window.Plotly.newPlot('pid-control', data, layout)
</script>
</pre>
<p height="480" id="container" width="640"></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" type="text/javascript"></script>
<script type="text/python"></script>
</pre>